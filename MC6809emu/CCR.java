/**
 * This class details the condition code register (CCR) The CCR defines the
 * state of the processor flags at any given time
 * 
 * @author Robert Wilson
 * 
 */
public class CCR {

	/** Instance variables */
	private boolean set = false;

	/** Instance of GUI class */
	private EmuGUI guiInstance;

	/**
	 * Bit 0 (C) is the Carry Flag, usually generated by the binary carry from
	 * the MSB of the operation (ADC, ADD) -- this is an unsigned overflow
	 * 
	 * C is also used to represent a 'borrow' (a NOT-carry) to and from
	 * subtract-like instructions (CMP, NEG, SBC, SUB), and MUL uses C to
	 * represent b7 of the result for round-off purposes
	 * 
	 * Data movement and logical operations do not affect C, while arithmetic
	 * operations set C, if appropriate
	 */
	public void setCBit(boolean set) {
		this.set = set;
	}

	public boolean cBit() {
		return set;
	}

	/**
	 * Bit 1 (V) is the Overflow Flag, set when an operation causes a
	 * two's-complement arithmetic overflow, which is detected if the carry from
	 * the MSB in the binary ALU does not match the carry from the MSB-1
	 * 
	 * Loads, stores and logical operations clear V, while arithmetic operations
	 * set V if appropriate
	 */
	public void setVBit(boolean set) {
		this.set = set;
	}

	public boolean vBit() {
		return set;
	}

	/**
	 * Bit 2 (Z) is the Zero Flag, set if the result of the previous operation
	 * was identically zero
	 * 
	 * Loads, stores, logical and arithmetic operations set Z if appropriate
	 */
	public void setZBit(boolean set) {
		this.set = set;
		if (set == true) {
			System.out.println("Z set in CCR class");
		}
	}

	public boolean zBit() {
		return set;
	}

	/**
	 * Bit 3 (N) is the negative flag containing the value of the MSB of the
	 * result of the preceding operation, thus a negative two's complement
	 * result will set N
	 * 
	 * Loads, stores, logical and arithmetic operations all set N if appropriate
	 * 
	 * If two's complement overflow occurs the sign of the result (& the N flag)
	 * will be incorrect, thus two's complement branches use the expression (N
	 * XOR V) to obtain an always valid sign result
	 */
	public void setNBit(boolean set) {
		this.set = set;
	}

	public boolean nBit() {
		return set;
	}

	/**
	 * Bit 4 (I) is the IRQ mask bit
	 * 
	 * If I is set the processor will not recognise interrupts from the IRQ line
	 * 
	 * NMI, FIRQ, IRQ, RESET and SWI all set I, while SW12 and SW13 do not
	 */
	public void setIBit(boolean set) {
		this.set = set;
	}

	public boolean iBit() {
		return set;
	}

	/**
	 * Bit 5 (H) is the half-carry bit and is used to indicate a carry from b3
	 * in the ALU as a result of an 8-bit addition only (ADC or ADD)
	 * 
	 * H is used by the DAA instruction to perform a (BCD) decimal add adjust
	 * operation
	 * 
	 * The state of the H flag is undefined in all subtract-like instructions to
	 * allow for future expansion; software must not depend upon a particular
	 * state of the H flag after subtract operations
	 */
	public void setHBit(boolean set) {
		this.set = set;
	}

	public boolean hBit() {
		return set;
	}

	/**
	 * Bit 6 (F) is the FIRQ mask bit
	 * 
	 * If F is set the processor will not recognise interrupts from the FIRQ
	 * line
	 * 
	 * NMI, FIRQ, RESET and SWI all set F, while SW12, SW13 and IRQ do not
	 */
	public void setFBit(boolean set) {
		this.set = set;
	}

	public boolean fBit() {
		return set;
	}

	/**
	 * Bit 7 (E) is the entire flag and indicates either the complete machine
	 * state (all the registers) or the subset state (PC and CC) is being
	 * stacked. E is used by the RTI instruction to determine the extent of the
	 * un-stacking, thus allowing some interrupt handling routines which work
	 * with both fast and slow interrupts
	 * 
	 * FIRQ will clear E while IRQ, NMI, SWI, SWI2 and SWI3 will set E before
	 * stacking
	 * 
	 * The E bit associated with the saved registers is in the E flag position
	 * in the CC of the stacked state; the E bit in the processor has little
	 * meaning
	 */
	public void setEBit(boolean set) {
		this.set = set;
	}

	public boolean eBit() {
		return set;
	}

}
